var documenterSearchIndex = {"docs":
[{"location":"#PortHamiltonianModelReduction","page":"Home","title":"PortHamiltonianModelReduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for PortHamiltonianModelReduction.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A Julia package implementing model reduction techniques for port-Hamiltonian systems.","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"import Random\nRandom.seed!(1234) # for reproducibility\n\nusing LinearAlgebra, ControlSystemsBase\nusing PortHamiltonianSystems, PortHamiltonianModelReduction\nusing PortHamiltonianBenchmarkSystems\n\nJ, R, Q, B = construct_system(SingleMSDConfig());\nΣ = phss(J, R, Q, B, zero(B), 1e-6*I(2), zeros(2,2)); # create pH system with the artificial feedthrough term 1e-6*I(2)\nsize(Σ.G) # (100, 2)\n\nΣ = phminreal(Σ); # structure preserving minimal realization\nsize(Σ.G) # (73, 2)\n\nr = 10 # reduced order\n\nΣr1 = phirka(Σ, r);\nnorm(Σ - Σr1) # 0.08325552559202813\n\nΣr2 = prbt(Σ, r);\nnorm(Σ - Σr2) # 0.0031763828389874994\n\nΣr3 = irka(ss(Σ), r);\nnorm(Σ - Σr3) # 0.0016571113588666688\nispassive(Σr3) # false\n\nΣr4, _ = klap(Σr3);\nnorm(Σ - Σr4) # 0.0016577342723135616\nispassive(Σr4) # true","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"T. Breiten and T. Stykel. Balancing-Related Model Reduction Methods. In: Model Order Reduction Volume 1: System- and Data-Driven Methods and Algorithms, edited by P. Benner, S. Grivet-Talocia, A. Quarteroni, G. Rozza, W. Schilders and L. M. Silveira (De Gruyter, 2021); pp. 15–56.\n\n\n\nT. Holicki, J. Nicodemus, P. Schwerdtner and B. Unger. Energy Matching in Reduced Passive and Port-Hamiltonian Systems. SIAM J. Control Optim. 63, 2154–2176 (2025).\n\n\n\nS. Gugercin, A. C. Antoulas and C. Beattie, mathcalH_2 Model Reduction for Large-Scale Linear Dynamical Systems. SIAM J. Matrix Anal. Appl. 30, 609–638 (2008).\n\n\n\nJ. Nicodemus, M. Voigt, S. Gugercin and B. Unger. KLAP: KYP Lemma Based Low-Rank Approximation for mathcalH_2-Optimal Passivation. ArXiv e-print 2501.05178 (2025).\n\n\n\nB. Peherstorfer and K. Willcox. Data-Driven Operator Inference for Nonintrusive Projection-Based Model Reduction. Computer Methods in Applied Mechanics and Engineering 306, 196–215 (2016).\n\n\n\nS. Grivet-Talocia and L. Silveira. Post-processing methods for passivity enforcement. In: Model Order Reduction: Volume 1 – System- and Data-Driven Methods and Algorithms, edited by P. Benner, S. Grivet-Talocia, A. Quarteroni, G. Rozza, W. Schilders and L. M. Silveira (De Gruyter, Berlin, Boston, 2021); pp. 139–180.\n\n\n\nB. Dumitrescu. Parameterization of Positive-Real Transfer Functions with Fixed Poles. IEEE Trans. Circuits Syst. I. Regul. Pap. 49, 523–526 (2002).\n\n\n\nC. Coelho, J. Phillips and L. Silveira. A Convex Programming Approach for Generating Guaranteed Passive Approximations to Tabulated Frequency-Data. IEEE Trans. Comput.-Aided Des. Integr. Circuits Syst. 23, 293–301 (2004).\n\n\n\nS. Gugercin, R. V. Polyuga, C. Beattie and A. van der Schaft. Structure-Preserving Tangential Interpolation for Model Reduction of Port-Hamiltonian Systems. Automatica J. IFAC 48, 1963–1974 (2012).\n\n\n\nR. Morandin, J. Nicodemus and B. Unger. Port-Hamiltonian Dynamic Mode Decomposition. SIAM J. Sci. Comput. 45, A1690–A1710 (2023).\n\n\n\nU. Desai and D. Pal. A Transformation Approach to Stochastic Model Reduction. IEEE Trans. Automat. Control 29, 1097–1100 (1984).\n\n\n\n","category":"page"},{"location":"API/","page":"API","title":"API","text":"","category":"page"},{"location":"API/#PortHamiltonianModelReduction.TimeDomainData","page":"API","title":"PortHamiltonianModelReduction.TimeDomainData","text":"TimeDomainData{T}\n\nData structure to hold time-domain simulation data. See tddata for a convenient constructor.\n\nFields\n\nẊ: State derivative matrix.\nX: State matrix.\nU: Input matrix.\nY: Output matrix.\nt: Time vector.\n\n\n\n\n\n","category":"type"},{"location":"API/#PortHamiltonianModelReduction.bt-Tuple{ControlSystemsBase.StateSpace, Any}","page":"API","title":"PortHamiltonianModelReduction.bt","text":"Σr = bt(Σ::StateSpace, r; Lx=grampd(Σ, :o), Ly=grampd(Σ, :c)')\n\nReduces the state dimension of the system Σ to r using standard square root balanced truncation (see for instance [1]). The cholesky factors of the Gramians can passed as optional arguments Lx and Ly. The default values are the cholesky factors of the observability and controllability Gramians.\n\n\n\n\n\n","category":"method"},{"location":"API/#PortHamiltonianModelReduction.chirp","page":"API","title":"PortHamiltonianModelReduction.chirp","text":"chirp(A=1.0, f0=1e-2, f1=1e1, T=2.0)\n\nGenerates a chirp signal with amplitude A, starting frequency f0, ending frequency f1, and duration T.\n\n\n\n\n\n","category":"function"},{"location":"API/#PortHamiltonianModelReduction.ephminreal-Tuple{PortHamiltonianSystems.PortHamiltonianStateSpace}","page":"API","title":"PortHamiltonianModelReduction.ephminreal","text":"Σph = ephminreal(Σph::PortHamiltonianStateSpace; kwargs...)\n\nComputes a minimal realization of the (extended) pH system (see [2, Cor. 4.6])\n\n\n\n\n\n","category":"method"},{"location":"API/#PortHamiltonianModelReduction.estimate_ham-Tuple{PortHamiltonianModelReduction.TimeDomainData, AbstractVector}","page":"API","title":"PortHamiltonianModelReduction.estimate_ham","text":"Q, err = estimate_ham(data::TimeDomainData, H::AbstractVector; kwargs...)\n\nEstimates the Hamiltonian Hessian Q from time-domain data and measurements H of the Hamiltonian.\n\n\n\n\n\n","category":"method"},{"location":"API/#PortHamiltonianModelReduction.hdss-NTuple{7, Any}","page":"API","title":"PortHamiltonianModelReduction.hdss","text":"Σqo = hdss(J, R, Q, G, P, S, N)\nΣqo = hdss(Σph)\n\nConverts a PortHamiltonianStateSpace to a QuadraticOutputStateSpace (Hamiltonian dynamic).\n\n\n\n\n\n","category":"method"},{"location":"API/#PortHamiltonianModelReduction.irka-Tuple{ControlSystemsBase.StateSpace, Any, Any}","page":"API","title":"PortHamiltonianModelReduction.irka","text":"Σr = irka(Σ::StateSpace, r; tol=1e-3, max_iter=200)\n\nReduces the state dimension of the system Σ to r using the iterative rational Krylov algorithm (IRKA) [3].\n\n\n\n\n\n","category":"method"},{"location":"API/#PortHamiltonianModelReduction.klap","page":"API","title":"PortHamiltonianModelReduction.klap","text":"klap(Σ::StateSpace; L0=L0(Σ), M=M(Σ), P=gram(Σ, :c); recycl=:schur, restart=false, α=1e-8, ε=1e-4, verbose=true, kwargs...) -> Σp, res\n\nPassivates a system Σ using KLAP [4]. The optimization problem is solved using LBFGS.\n\n\n\n\n\n","category":"function"},{"location":"API/#PortHamiltonianModelReduction.klap_inital_guess","page":"API","title":"PortHamiltonianModelReduction.klap_inital_guess","text":"klap_inital_guess(Σ, ΔD=0.0; ε=1e-8) -> L0, ΔD\n\nComputes an initial guess for KLAP [4]. The initial guess is computed by perturbing the feedthrough matrix to achieve a passive realization. Then the perturbed system is used to compute the initial guess. The perturbation ΔD can be specified, otherwise it is computed using ΔD(Σ).\n\n\n\n\n\n","category":"function"},{"location":"API/#PortHamiltonianModelReduction.matchnrg-Tuple{PortHamiltonianSystems.PortHamiltonianStateSpace, PortHamiltonianSystems.PortHamiltonianStateSpace}","page":"API","title":"PortHamiltonianModelReduction.matchnrg","text":"Σrem = matchnrg(Σ::PortHamiltonianStateSpace, Σr::PortHamiltonianStateSpace; solver=:BFGS, kwargs...)\n\nApplies energy matching [2] to the ROM Σr to match the Hamiltonian dynamics of the original system Σ.  If solver is :Hypatia or :COSMO, it uses semidefinite programming with the specified optimizer.  If solver is :BFGS, it uses the barrier method with BFGS optimization.  If solver is :ARE, the best solution of the ARE is returned.\n\n\n\n\n\n","category":"method"},{"location":"API/#PortHamiltonianModelReduction.matchnrg_are-Tuple{QuadraticOutputSystems.QuadraticOutputStateSpace, ControlSystemsBase.StateSpace}","page":"API","title":"PortHamiltonianModelReduction.matchnrg_are","text":"Σphr = matchnrg_are(Σ::QuadraticOutputStateSpace, Σr::StateSpace; kwargs...)\n\nSolves the energy matching problem where the solution set is replaced with solutions of the ARE.\n\n\n\n\n\n","category":"method"},{"location":"API/#PortHamiltonianModelReduction.matchnrg_barrier-Tuple{QuadraticOutputSystems.QuadraticOutputStateSpace, ControlSystemsBase.StateSpace}","page":"API","title":"PortHamiltonianModelReduction.matchnrg_barrier","text":"Σph = matchnrg_barrier(Σ, Σr; Σr0=nothing, kwargs...)\n\nSolves the energy matching problem using the barrier method.\n\n\n\n\n\n","category":"method"},{"location":"API/#PortHamiltonianModelReduction.matchnrg_sdp","page":"API","title":"PortHamiltonianModelReduction.matchnrg_sdp","text":"Σphr = matchnrg_sdp(Σ::QuadraticOutputStateSpace, Σr::StateSpace; optimizer=COSMO.Optimizer, ε=1e-8, kwargs...)\n\nSolves the energy matching problem using semidefinite programming.\n\n\n\n\n\n","category":"function"},{"location":"API/#PortHamiltonianModelReduction.opinf-Tuple{PortHamiltonianModelReduction.TimeDomainData, Matrix}","page":"API","title":"PortHamiltonianModelReduction.opinf","text":"Σr, res = opinf(data::TimeDomainData, Wr::Matrix)\n\nComputes a ROM Σr from time-domain data via operator inference (OpInf) [5].  The error of the OpInf problem is returned as res. The data is projected using with the matrix Wr, which is typically a POD basis.\n\n\n\n\n\n","category":"method"},{"location":"API/#PortHamiltonianModelReduction.passivate","page":"API","title":"PortHamiltonianModelReduction.passivate","text":"passivate(Σ::StateSpace, method=:klap, args...; kwargs...) -> Σp, res\n\nPassivate the system Σ using the method method. The available methods are:\n\n:klap: KLAP optimization [4]\n:lmi: LMI optimization [6]\n:lmi_tp: LMI optimization with trace parametrization [7, 8]\n\nThe remaining arguments args and keyword arguments kwargs are passed to the corresponding passivation function.\n\n\n\n\n\n","category":"function"},{"location":"API/#PortHamiltonianModelReduction.passivate_lmi-Tuple{ControlSystemsBase.StateSpace}","page":"API","title":"PortHamiltonianModelReduction.passivate_lmi","text":"passivate_lmi(Σ::StateSpace; kwargs...) -> Σp, model\n\nSolves the passivation problem for a given state-space system Σ using the positive real LMI constraints [6].\n\n\n\n\n\n","category":"method"},{"location":"API/#PortHamiltonianModelReduction.passivate_lmi_tp-Tuple{ControlSystemsBase.StateSpace}","page":"API","title":"PortHamiltonianModelReduction.passivate_lmi_tp","text":"passivate_lmi_tp(Σ::StateSpace; kwargs...) -> Σp, model\n\nSolves the passivation problem for a given state-space system Σ using the positive real LMI constraints with trace parametrization [7, 8].\n\n\n\n\n\n","category":"method"},{"location":"API/#PortHamiltonianModelReduction.pgprojection","page":"API","title":"PortHamiltonianModelReduction.pgprojection","text":"pgprojection(Σph::PortHamiltonianStateSpace, V::Matrix, W::Matrix=Σph.Q * V / (V' * Σph.Q * V))\npgprojection(Σ::StateSpace, V::Matrix, W::Matrix=V)\n\nApplies a (Petrov-)Galerkin projection to a pH or LTI. In the pH case, the W matrix has to be chosen such that the structure is preserved. The default choice is W = Σph.Q * V / (V' * Σph.Q * V), which is proposed in [9].\n\n\n\n\n\n","category":"function"},{"location":"API/#PortHamiltonianModelReduction.phdmd-Tuple{PortHamiltonianModelReduction.TimeDomainData, AbstractVector}","page":"API","title":"PortHamiltonianModelReduction.phdmd","text":"Σph, err = phdmd(data::TimeDomainData, H::AbstractVector; kwargs...)\nΣph, err = phdmd(data::TimeDomainData, Q::AbstractMatrix; kwargs...)\n\nComputes a pH system Σph that approximates given time-domain data and a candidate Q for the Hessian of the Hamiltonian or measurements H of the Hamiltonian using the pHDMD method [10].\n\n\n\n\n\n","category":"method"},{"location":"API/#PortHamiltonianModelReduction.phdmd_initial_guess-Tuple{PortHamiltonianModelReduction.TimeDomainData, AbstractMatrix}","page":"API","title":"PortHamiltonianModelReduction.phdmd_initial_guess","text":"Γ, W, err = phdmd_initial_guess(data::TimeDomainData, Q::AbstractMatrix; kwargs...)\n\nComputes an initial guess Γ, W for the pHDMD problem from time-domain data data and a candidate Q for the Hessian of the Hamiltonian (see [10, Thm. 3.7]).\n\n\n\n\n\n","category":"method"},{"location":"API/#PortHamiltonianModelReduction.phdmd_sdp-Tuple{PortHamiltonianModelReduction.TimeDomainData}","page":"API","title":"PortHamiltonianModelReduction.phdmd_sdp","text":"Σph = phdmd_sdp(data::TimeDomainData; kwargs...)\nΣph = phdmd_sdp(data::TimeDomainData, Q::AbstractMatrix; kwargs...)\n\nComputes a pH system Σph that approximates given time-domain data using semidefinite programming. Either the Hessian of the Hamiltonian Q is provided or also learned from the data.\n\n\n\n\n\n","category":"method"},{"location":"API/#PortHamiltonianModelReduction.phirka-Tuple{PortHamiltonianSystems.PortHamiltonianStateSpace, Any, Any}","page":"API","title":"PortHamiltonianModelReduction.phirka","text":"Σr = phirka(Σph::PortHamiltonianStateSpace, r; tol=1e-3, max_iter=50)\n\nReduces the state dimension of the port-Hamiltonian system Σph to r using pHIRKA [9].\n\n\n\n\n\n","category":"method"},{"location":"API/#PortHamiltonianModelReduction.pod-Tuple{Any, Any, Any}","page":"API","title":"PortHamiltonianModelReduction.pod","text":"Σr = pod(Σ, X, r)\nΣr = pod(Σ, V, W)\n\nReturns a ROM Σr of size r for the system Σ using the POD (Petrov-)Galerkin method.\n\n\n\n\n\n","category":"method"},{"location":"API/#PortHamiltonianModelReduction.podbasis-Tuple","page":"API","title":"PortHamiltonianModelReduction.podbasis","text":"podbasis(X::AbstractMatrix, r::Int; kwargs...)\npodbasis(F::SVD, r::Int; kwargs...)\n\nReturns the POD basis via the truncated singular value decomposition of a data matrix X. Alternatively, it can be cast on a F::SVD object, such that the SVD is not recomputed.\n\n\n\n\n\n","category":"method"},{"location":"API/#PortHamiltonianModelReduction.prbs","page":"API","title":"PortHamiltonianModelReduction.prbs","text":"prbs(t, A=1.0, order=7)\n\nGenerates a pseudo-random binary sequence (PRBS) signal with amplitude A and specified order.\n\n\n\n\n\n","category":"function"},{"location":"API/#PortHamiltonianModelReduction.prbt-Tuple{ControlSystemsBase.StateSpace, Any}","page":"API","title":"PortHamiltonianModelReduction.prbt","text":"Σr = prbt(Σ, r; Lx=prgrampd(Σ, :o), Ly=prgrampd(Σ, :c))\n\nReduces the state dimension of the system Σ to r using positive real balanced truncation (PRBT) [11]. The cholesky factors of the positive real Gramians can passed as optional arguments Lx and Ly, in order to avoid recomputation.  Σ can be a StateSpace or a PortHamiltonianStateSpace, which will then also be the return type. In the case of a PortHamiltonianStateSpace,  for the conversion to the ROM the minimal solution of the KYP inequality is used as the Hessian of the Hamiltonian.\n\n\n\n\n\n","category":"method"},{"location":"API/#PortHamiltonianModelReduction.sawtooth","page":"API","title":"PortHamiltonianModelReduction.sawtooth","text":"sawtooth(A=1.0, T=1.0)\n\nGenerates a sawtooth wave signal with amplitude A and period T.\n\n\n\n\n\n","category":"function"},{"location":"API/#PortHamiltonianModelReduction.skew_proc-Tuple{AbstractMatrix, AbstractMatrix}","page":"API","title":"PortHamiltonianModelReduction.skew_proc","text":"Γ, err = skew_proc(T::AbstractMatrix, Z::AbstractMatrix; kwargs...)\n\nComputes the analytic solution of the skew-symmetric Procrustes problem (see for instance [10, Thm. 3.4]).\n\n\n\n\n\n","category":"method"},{"location":"API/#PortHamiltonianModelReduction.step","page":"API","title":"PortHamiltonianModelReduction.step","text":"step(A=1.0, ts=1.0)\n\nGenerates a step signal with amplitude A and step time ts.\n\n\n\n\n\n","category":"function"},{"location":"API/#PortHamiltonianModelReduction.tddata-Tuple","page":"API","title":"PortHamiltonianModelReduction.tddata","text":"data = tddata(Ẋ::Matrix{T},X::Matrix{T},U::Matrix{T},Y::Matrix{T},t::Vector{T})\ndata = tddata(res::SimResult)\n\nCreates a TimeDomainData object with element type T.\n\n\n\n\n\n","category":"method"}]
}
